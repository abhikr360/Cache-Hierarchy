Hierarchical-Cache-Simulator
=========================
This repository contains a modular C++ implementation of three level cache hierarchy for multi-core processors. It provides a wide range of functionalities such as different choice of replacement policy and different architectures. For eg. One can keep separate L1/L2 cache for data and instruction or unified cache.

How to use
-------------
+ First generate address trace of a program. To understand how to do this, visit [this](https://github.com/mkbera/multilevel-cache-sim) repository. We will assume that trace is stored in a file called `addrtrace.out`
+ Specify your architecture by appropriately modifying the code `simulate.cpp`
+ Compile using `g++ -std=c++11 simulate.cpp L1Cache.cpp L2Cache.cpp -o simulate`
+ Run `./simulate {}addrtrace.out > LLCtrace.out'
Now you have trace for LLC in the file `LLCtrace.out`.
+ Change specifications of LLC according to your need
+ Compile using `g++ -std=c++11 llc_simulation.cpp LLC.cpp CE_Belady.cpp -o llc`
+ Run `./llc LLCtrace.out LLCtrace_hitfile.out LLCtrace_sharefile.out LLCtrace_reusefile.out` These arguments will be explained later.


Description of different files/folders
-----------------------------------------
- `CE_Belady.cpp, CE_Belady.h` contains definitions and declarations of cache entry required for running Belady's cache replacement policy
- `L1Cache.cpp, L1Cache.h` contains definitions and declarations of L1 Cache
- `L2Cache.cpp, L2Cache.h` contains definitions and declarations of L2 Cache
- `LLC.cpp, LLC.h` contains definitions and declarations of Last level Cache
- `constants.h` contains declarations of few constanst used in the program
- `belady.cpp` contains the commented preprocessing code needed for efficient implementation of Belady's policy
- `simulate.cpp` contains the code which specifies the whole architecture. Number of cores, how L1 and L2 cache are related to each other, what is their size(`size = num_sets * associativity * size of Cache Block`). Note that size of cache block is assumed to be 64B. This code finally simulates the address trace generated by PIN tool and generates trace for LLC
- `llc-simulation.cpp` contains the code which specifies the properties of LLC. It takes the trace generated by `simulate.cpp` as input and runs it through the LLC, performs analysis on it.
- `l1l2_run.py` contains the driver script for running `simulate.cpp`
- `llc-run.py` contains the driver script for running `llc-simulation.cpp`
- `llc-lru.c` is a C implementation of LRU algorithm
- `llc-belady.c` is a C implementation of Belady Algorithm
-  `llc-pc.c` is the implementation in which we calculate the probability of getting next hit based on PC. We maintain
hit count
- `llc-prob.c` is the implementation in which we calculate the probability of getting next hit based on memory location accessed. We maintain hit count

- `llc-prob-share.c` is the implementation in which we calculate the probability of getting next hit based on memory location accessed. We maintain hit count separately for shared cache blocks and non-shared cache blocks
- `prob-bel.c` Contains code that runs belady's algorithm and count based probability algorithm simulatenously. Can be used to see where the algorithm makes poor choice in replacement decision
- The folder `analysis` contains few codes to analyze the results obtained after LLC simulation

Note that, I am collecting hit, reuse and sharing statistics of cache blocks in LLC. One can very easily modify/add code in `L1Cache.cpp, L2Cache.cpp, LLC.cpp` to collect different statistics. Moreover, one can add new replacement policies. The arguments in `LLC.cpp` are the names of files in which output should be written. 

<*> This code has been tested on Ubuntu machine and works without any issue. If you have any question, comment, doubt, feel free to get in touch with Abhishek Kumar[theabhishek763@gmail.com]
